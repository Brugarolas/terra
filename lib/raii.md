# RAII - Resource management
Resource acquisition is initialization ([RAII](https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization)) provides a deterministic means of safe resource management. It is generally associated with systems programming languages such as *c++* and *rust*.

In the following I summarize the experimental implementation that you can find [here](https://github.com/renehiemstra/terra/tree/raii). The socalled [Big Three](https://en.wikipedia.org/wiki/Rule_of_three_(C%2B%2B_programming)) are supported:
* object destruction
* copy assignment
* copy construction

Terra does not support rvalue references (introduced e.g. in *c++11*), so the experimental RAII support is comparable to that of *C++03* or *rust*. 

## Feature summary
Compiler support for the following methods:
```
A.methods.__init(self : &A)
A.methods.__dtor(self : &A)
(A or B).methods.__copy(from : &A, to : &B)
```
These methods support the implementation of smart containers and smart pointers, like *std::string*, *std::vector* and *std::unique_ptr*, *std::shared_ptr*, *boost:offset_ptr* in C++.

The design does not introduce any breaking changes. No new keywords are introduced. Heap resources are acquired and released using the regular C stdlib functions such malloc and free, leaving memory allocation in the hands of the programmer.

If implemented, these methods are inserted judiciously during the type checking phase, implemented in *terralib.lua*. All these metamethods can be implemented as macro's or as terra functions.

## Compiler supported methods for RAII
A managed type is one that implements at least `__dtor` and optionally `__init` and `__copy` or, by induction, has fields or subfields that are of a managed type. In the following I assume `struct A` is a managed type.

### Object initialization
`__init` is used to initialize managed variables:
```
    A.methods.__init(self : &A)
```
The compiler checks for an `__init` method in any variable definition statement, without explicit initializer, and emits the call right after the variable definition, e.g.
```
    var a : A
    a:__init()
```
### Copy assignment
`__copy` enables specialized copy-assignment and, combined with `__init`, copy construction. `__copy` takes two arguments, which can be different, as long as one of them is a managed type, e.g.
```
    A.metamethods.__copy(from : &A, to : &B)
```
and / or
```
    A.metamethods.__copy(from : &B, to : &A)
```
If `a : A` is a managed type, then the compiler will replace a regular assignment by a call to the implemented `__copy` method
```
    b = a   ---->   A.methods.__copy(a, b) 
```
or 
```
    a = b   ---->   A.methods.__copy(b, a)
```
`__copy` can be an overloaded terra function or a macro.

The programmer is responsable for managing any heap resources associated with the arguments of the `__copy` method.

### Copy construction
In object construction, `__copy` is combined with `__init` to perform copy construction. For example,
```
    var b = a
```
is replaced by the following statements
```
    var b : B
    b:__init()                  --generated by compiler if an `__init` is implemented
    A.methods.__copy(a, b)
```
If the right `__copy` method is not implemented but a user defined `__cast` metamethod exists that can cast one of the arguments to the correct type, then the cast is performed and then the relevant copy method is applied.

### Object destruction
`__dtor` can be used to free heap memory
```
    A.methods.__dtor(self : &A)
```
The implementation adds a deferred call to `__dtor ` near the end of a scope, right before a potential return statement, for all variables local to the current scope that are not returned. Hence, `__dtor` is tied to the lifetime of the object. For example, for a block of code the compiler would generate
```
do
    var x : A, y : A
    ...
    ...
    defer x:__dtor()    --generated by compiler
    defer y:__dtor()    --generated by compiler
end
```
or in case of a terra function
```
terra foo(x : A)
    var y : A, z : A
    ...
    ...
    defer z:__dtor()    --generated by compiler
    return y
end
```
`__dtor` is also called before any regular assignment (if a __copy method is not implemented)  to free 'old' resources. So
```
    a = b
```
is replaced by
```
    a:__dtor()  --generated by compiler
    a = b
```
## Compositional API's
If a struct has fields or subfields that are managed types, but do not implement `__init`, `__copy` or `__dtor`, then the compiler will generate default methods that inductively call existing `__init`, `__copy` or `__dtor` methods for its fields and subfields. This enables compositional API's like `vector(vector(int))` or  `vector(string)`. This is implemented as an extension to *terralib.lua* in *lib/terralibext.t*.

## Current limitations
* Tuple (copy) assignment (regular or using `__copy`) are prohibited by the compiler in case of managed variables. This is done to prevent memory leaks or unwanted deletions in assignments such as
```
    a, b = b, a
```
* Currently, there is no way to prevent unwanted calls to `__dtor` in cases such as the following. Consider
```
terra foo()
    var b : A
    return bar(b)
end
```
which will get expanded to 
```
terra foo()
    var b : A
    defer b:__dtor()    --generated by compiler
    return bar(b)
end
```
If `bar` would return `b` then its associated heap resources would be released before they can be used in the outer scope.

## Roadmap
The current implementation already works in a range of important applications, as can be seen in the tests and the examples above. To remove the noted limitations and to enable graceful compile-time errors my plan is:
* support for *affine types* (similar to *rust*) by checking, at compile time, that a managed variable is used (passed by value) not more than once. This essentially means that the variable is moved from (not copied) on every use. This is not restrictive, since in general you would pass managed objects by reference, not by value.
* borrow checking (similar to *rust*) by counting, at compile time, the number of references.


## Examples
The check for metamethods.__dtor is done once in checkblock(...) (which checks a scoped environment) and metamethods.(__init, __copy, __dtor) are checked in several parts of checkassignment(...). These checks are cheap, especially if none of the metamethods are implemented.